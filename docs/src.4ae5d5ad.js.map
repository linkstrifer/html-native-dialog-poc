{"version":3,"sources":["node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js","src/index.js"],"names":["dialogPolyfill","supportCustomEvent","window","CustomEvent","createsStackingContext","el","document","body","s","getComputedStyle","invalid","k","ok","undefined","opacity","position","webkitOverflowScrolling","parentElement","findNearestDialog","localName","safeBlur","shadowRoot","activeElement","blur","inNodeList","nodeList","node","i","length","isFormMethodDialog","hasAttribute","getAttribute","toLowerCase","findFocusableElementWithin","hostElement","opts","query","map","push","target","querySelector","join","Element","prototype","elems","querySelectorAll","tagName","isConnected","element","contains","dialogPolyfillInfo","dialog","dialog_","replacedStyleTop_","openAsModal_","setAttribute","show","bind","showModal","close","returnValue","MutationObserver","maybeHideModal","observe","attributes","attributeFilter","removed","timeout","cb","downgradeModal","delayModel","ev","cand","type","substr","clearTimeout","setTimeout","forEach","name","addEventListener","Object","defineProperty","set","setOpen","get","backdrop_","createElement","className","backdropClick_","event","x","createEvent","initCustomEvent","bubbles","cancelable","detail","Event","style","zIndex","top","parentNode","removeChild","dm","removeDialog","value","removeAttribute","e","focus","fake","insertBefore","firstChild","tabIndex","redirectedEvent","initMouseEvent","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","dispatchEvent","stopPropagation","focus_","updateZIndex","dialogZ","backdropZ","Error","open","pushDialog","console","warn","needsCentering","reposition","nextSibling","opt_returnValue","closeEvent","scrollTop","documentElement","topValue","innerHeight","offsetHeight","Math","max","styleSheets","styleSheet","cssRules","j","rule","selectedNodes","selectorText","cssTop","getPropertyValue","cssBottom","computedStyle","bottom","isInlinePositionSetByStylesheet","HTMLDialogElement","forceRegisterDialog","pendingDialogStack","checkDOM","checkDOM_","overlay","forwardTab_","handleKey_","handleFocus_","zIndexLow_","zIndexHigh_","mo_","records","rec","c","removedNodes","concat","DialogManager","blockDocument","childList","subtree","unblockDocument","removeEventListener","disconnect","updateStacking","dpi","last","appendChild","containedByTopDialog_","candidate","preventDefault","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","keyCode","cancelEvent","slice","indexOf","allowed","unshift","index","splice","formSubmitter","useValue","testForm","method","methodDescriptor","getOwnPropertyDescriptor","HTMLFormElement","realGet","call","realSet","v","defaultPrevented","form","offsetX","offsetY","nativeFormSubmit","submit","replacementFormSubmit","openButton","closeButton","dialogStatus","setOpenState","opener","checkStatus","innerText","registerDialog"],"mappings":"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","file":"src.4ae5d5ad.js","sourceRoot":"..","sourcesContent":["// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent = window.CustomEvent;\nif (!supportCustomEvent || typeof supportCustomEvent === 'object') {\n  supportCustomEvent = function CustomEvent(event, x) {\n    x = x || {};\n    var ev = document.createEvent('CustomEvent');\n    ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n    return ev;\n  };\n  supportCustomEvent.prototype = window.Event.prototype;\n}\n\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */\nfunction createsStackingContext(el) {\n  while (el && el !== document.body) {\n    var s = window.getComputedStyle(el);\n    var invalid = function(k, ok) {\n      return !(s[k] === undefined || s[k] === ok);\n    };\n\n    if (s.opacity < 1 ||\n        invalid('zIndex', 'auto') ||\n        invalid('transform', 'none') ||\n        invalid('mixBlendMode', 'normal') ||\n        invalid('filter', 'none') ||\n        invalid('perspective', 'none') ||\n        s['isolation'] === 'isolate' ||\n        s.position === 'fixed' ||\n        s.webkitOverflowScrolling === 'touch') {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n}\n\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */\nfunction findNearestDialog(el) {\n  while (el) {\n    if (el.localName === 'dialog') {\n      return /** @type {HTMLDialogElement} */ (el);\n    }\n    el = el.parentElement;\n  }\n  return null;\n}\n\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */\nfunction safeBlur(el) {\n  // Find the actual focused element when the active element is inside a shadow root\n  while (el && el.shadowRoot && el.shadowRoot.activeElement) {\n    el = el.shadowRoot.activeElement;\n  }\n\n  if (el && el.blur && el !== document.body) {\n    el.blur();\n  }\n}\n\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */\nfunction inNodeList(nodeList, node) {\n  for (var i = 0; i < nodeList.length; ++i) {\n    if (nodeList[i] === node) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */\nfunction isFormMethodDialog(el) {\n  if (!el || !el.hasAttribute('method')) {\n    return false;\n  }\n  return el.getAttribute('method').toLowerCase() === 'dialog';\n}\n\n/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */\nfunction findFocusableElementWithin(hostElement) {\n  // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n  // alternative involves stepping through and trying to focus everything.\n  var opts = ['button', 'input', 'keygen', 'select', 'textarea'];\n  var query = opts.map(function(el) {\n    return el + ':not([disabled])';\n  });\n  // TODO(samthor): tabindex values that are not numeric are not focusable.\n  query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');  // tabindex != \"\", not disabled\n  var target = hostElement.querySelector(query.join(', '));\n\n  if (!target && 'attachShadow' in Element.prototype) {\n    // If we haven't found a focusable target, see if the host element contains an element\n    // which has a shadowRoot.\n    // Recursively search for the first focusable item in shadow roots.\n    var elems = hostElement.querySelectorAll('*');\n    for (var i = 0; i < elems.length; i++) {\n      if (elems[i].tagName && elems[i].shadowRoot) {\n        target = findFocusableElementWithin(elems[i].shadowRoot);\n        if (target) {\n          break;\n        }\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {Boolean} whether the element is in DOM\n */\nfunction isConnected(element) {\n  return element.isConnected || document.body.contains(element);\n}\n\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */\nfunction dialogPolyfillInfo(dialog) {\n  this.dialog_ = dialog;\n  this.replacedStyleTop_ = false;\n  this.openAsModal_ = false;\n\n  // Set a11y role. Browsers that support dialog implicitly know this already.\n  if (!dialog.hasAttribute('role')) {\n    dialog.setAttribute('role', 'dialog');\n  }\n\n  dialog.show = this.show.bind(this);\n  dialog.showModal = this.showModal.bind(this);\n  dialog.close = this.close.bind(this);\n\n  if (!('returnValue' in dialog)) {\n    dialog.returnValue = '';\n  }\n\n  if ('MutationObserver' in window) {\n    var mo = new MutationObserver(this.maybeHideModal.bind(this));\n    mo.observe(dialog, {attributes: true, attributeFilter: ['open']});\n  } else {\n    // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n    // seem to fire even if the element was removed as part of a parent removal. Use the removed\n    // events to force downgrade (useful if removed/immediately added).\n    var removed = false;\n    var cb = function() {\n      removed ? this.downgradeModal() : this.maybeHideModal();\n      removed = false;\n    }.bind(this);\n    var timeout;\n    var delayModel = function(ev) {\n      if (ev.target !== dialog) { return; }  // not for a child element\n      var cand = 'DOMNodeRemoved';\n      removed |= (ev.type.substr(0, cand.length) === cand);\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(cb, 0);\n    };\n    ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {\n      dialog.addEventListener(name, delayModel);\n    });\n  }\n  // Note that the DOM is observed inside DialogManager while any dialog\n  // is being displayed as a modal, to catch modal removal from the DOM.\n\n  Object.defineProperty(dialog, 'open', {\n    set: this.setOpen.bind(this),\n    get: dialog.hasAttribute.bind(dialog, 'open')\n  });\n\n  this.backdrop_ = document.createElement('div');\n  this.backdrop_.className = 'backdrop';\n  this.backdrop_.addEventListener('click', this.backdropClick_.bind(this));\n}\n\ndialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */ ({\n\n  get dialog() {\n    return this.dialog_;\n  },\n\n  /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */\n  maybeHideModal: function() {\n    if (this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) { return; }\n    this.downgradeModal();\n  },\n\n  /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */\n  downgradeModal: function() {\n    if (!this.openAsModal_) { return; }\n    this.openAsModal_ = false;\n    this.dialog_.style.zIndex = '';\n\n    // This won't match the native <dialog> exactly because if the user set top on a centered\n    // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n    // possible to polyfill this perfectly.\n    if (this.replacedStyleTop_) {\n      this.dialog_.style.top = '';\n      this.replacedStyleTop_ = false;\n    }\n\n    // Clear the backdrop and remove from the manager.\n    this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n    dialogPolyfill.dm.removeDialog(this);\n  },\n\n  /**\n   * @param {boolean} value whether to open or close this dialog\n   */\n  setOpen: function(value) {\n    if (value) {\n      this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');\n    } else {\n      this.dialog_.removeAttribute('open');\n      this.maybeHideModal();  // nb. redundant with MutationObserver\n    }\n  },\n\n  /**\n   * Handles clicks on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */\n  backdropClick_: function(e) {\n    if (!this.dialog_.hasAttribute('tabindex')) {\n      // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n      // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n      // would not be needed - clicks would move the implicit cursor there.\n      var fake = document.createElement('div');\n      this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n      fake.tabIndex = -1;\n      fake.focus();\n      this.dialog_.removeChild(fake);\n    } else {\n      this.dialog_.focus();\n    }\n\n    var redirectedEvent = document.createEvent('MouseEvents');\n    redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,\n        e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,\n        e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n    this.dialog_.dispatchEvent(redirectedEvent);\n    e.stopPropagation();\n  },\n\n  /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */\n  focus_: function() {\n    // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n    var target = this.dialog_.querySelector('[autofocus]:not([disabled])');\n    if (!target && this.dialog_.tabIndex >= 0) {\n      target = this.dialog_;\n    }\n    if (!target) {\n      target = findFocusableElementWithin(this.dialog_);\n    }\n    safeBlur(document.activeElement);\n    target && target.focus();\n  },\n\n  /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */\n  updateZIndex: function(dialogZ, backdropZ) {\n    if (dialogZ < backdropZ) {\n      throw new Error('dialogZ should never be < backdropZ');\n    }\n    this.dialog_.style.zIndex = dialogZ;\n    this.backdrop_.style.zIndex = backdropZ;\n  },\n\n  /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */\n  show: function() {\n    if (!this.dialog_.open) {\n      this.setOpen(true);\n      this.focus_();\n    }\n  },\n\n  /**\n   * Show this dialog modally.\n   */\n  showModal: function() {\n    if (this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');\n    }\n    if (!isConnected(this.dialog_)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');\n    }\n    if (!dialogPolyfill.dm.pushDialog(this)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');\n    }\n\n    if (createsStackingContext(this.dialog_.parentElement)) {\n      console.warn('A dialog is being shown inside a stacking context. ' +\n          'This may cause it to be unusable. For more information, see this link: ' +\n          'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');\n    }\n\n    this.setOpen(true);\n    this.openAsModal_ = true;\n\n    // Optionally center vertically, relative to the current viewport.\n    if (dialogPolyfill.needsCentering(this.dialog_)) {\n      dialogPolyfill.reposition(this.dialog_);\n      this.replacedStyleTop_ = true;\n    } else {\n      this.replacedStyleTop_ = false;\n    }\n\n    // Insert backdrop.\n    this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n\n    // Focus on whatever inside the dialog.\n    this.focus_();\n  },\n\n  /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */\n  close: function(opt_returnValue) {\n    if (!this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');\n    }\n    this.setOpen(false);\n\n    // Leave returnValue untouched in case it was set directly on the element\n    if (opt_returnValue !== undefined) {\n      this.dialog_.returnValue = opt_returnValue;\n    }\n\n    // Triggering \"close\" event for any attached listeners on the <dialog>.\n    var closeEvent = new supportCustomEvent('close', {\n      bubbles: false,\n      cancelable: false\n    });\n    this.dialog_.dispatchEvent(closeEvent);\n  }\n\n});\n\nvar dialogPolyfill = {};\n\ndialogPolyfill.reposition = function(element) {\n  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n  element.style.top = Math.max(scrollTop, topValue) + 'px';\n};\n\ndialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n  for (var i = 0; i < document.styleSheets.length; ++i) {\n    var styleSheet = document.styleSheets[i];\n    var cssRules = null;\n    // Some browsers throw on cssRules.\n    try {\n      cssRules = styleSheet.cssRules;\n    } catch (e) {}\n    if (!cssRules) { continue; }\n    for (var j = 0; j < cssRules.length; ++j) {\n      var rule = cssRules[j];\n      var selectedNodes = null;\n      // Ignore errors on invalid selector texts.\n      try {\n        selectedNodes = document.querySelectorAll(rule.selectorText);\n      } catch(e) {}\n      if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n        continue;\n      }\n      var cssTop = rule.style.getPropertyValue('top');\n      var cssBottom = rule.style.getPropertyValue('bottom');\n      if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\ndialogPolyfill.needsCentering = function(dialog) {\n  var computedStyle = window.getComputedStyle(dialog);\n  if (computedStyle.position !== 'absolute') {\n    return false;\n  }\n\n  // We must determine whether the top/bottom specified value is non-auto.  In\n  // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n  // Firefox returns the used value. So we do this crazy thing instead: check\n  // the inline style and then go through CSS rules.\n  if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||\n      (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {\n    return false;\n  }\n  return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n\n/**\n * @param {!Element} element to force upgrade\n */\ndialogPolyfill.forceRegisterDialog = function(element) {\n  if (window.HTMLDialogElement || element.showModal) {\n    console.warn('This browser already supports <dialog>, the polyfill ' +\n        'may not work correctly', element);\n  }\n  if (element.localName !== 'dialog') {\n    throw new Error('Failed to register dialog: The element is not a dialog.');\n  }\n  new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));\n};\n\n/**\n * @param {!Element} element to upgrade, if necessary\n */\ndialogPolyfill.registerDialog = function(element) {\n  if (!element.showModal) {\n    dialogPolyfill.forceRegisterDialog(element);\n  }\n};\n\n/**\n * @constructor\n */\ndialogPolyfill.DialogManager = function() {\n  /** @type {!Array<!dialogPolyfillInfo>} */\n  this.pendingDialogStack = [];\n\n  var checkDOM = this.checkDOM_.bind(this);\n\n  // The overlay is used to simulate how a modal dialog blocks the document.\n  // The blocking dialog is positioned on top of the overlay, and the rest of\n  // the dialogs on the pending dialog stack are positioned below it. In the\n  // actual implementation, the modal dialog stacking is controlled by the\n  // top layer, where z-index has no effect.\n  this.overlay = document.createElement('div');\n  this.overlay.className = '_dialog_overlay';\n  this.overlay.addEventListener('click', function(e) {\n    this.forwardTab_ = undefined;\n    e.stopPropagation();\n    checkDOM([]);  // sanity-check DOM\n  }.bind(this));\n\n  this.handleKey_ = this.handleKey_.bind(this);\n  this.handleFocus_ = this.handleFocus_.bind(this);\n\n  this.zIndexLow_ = 100000;\n  this.zIndexHigh_ = 100000 + 150;\n\n  this.forwardTab_ = undefined;\n\n  if ('MutationObserver' in window) {\n    this.mo_ = new MutationObserver(function(records) {\n      var removed = [];\n      records.forEach(function(rec) {\n        for (var i = 0, c; c = rec.removedNodes[i]; ++i) {\n          if (!(c instanceof Element)) {\n            continue;\n          } else if (c.localName === 'dialog') {\n            removed.push(c);\n          }\n          removed = removed.concat(c.querySelectorAll('dialog'));\n        }\n      });\n      removed.length && checkDOM(removed);\n    });\n  }\n};\n\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */\ndialogPolyfill.DialogManager.prototype.blockDocument = function() {\n  document.documentElement.addEventListener('focus', this.handleFocus_, true);\n  document.addEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});\n};\n\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */\ndialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n  document.documentElement.removeEventListener('focus', this.handleFocus_, true);\n  document.removeEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.disconnect();\n};\n\n/**\n * Updates the stacking of all known dialogs.\n */\ndialogPolyfill.DialogManager.prototype.updateStacking = function() {\n  var zIndex = this.zIndexHigh_;\n\n  for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n    dpi.updateZIndex(--zIndex, --zIndex);\n    if (i === 0) {\n      this.overlay.style.zIndex = --zIndex;\n    }\n  }\n\n  // Make the overlay a sibling of the dialog itself.\n  var last = this.pendingDialogStack[0];\n  if (last) {\n    var p = last.dialog.parentNode || document.body;\n    p.appendChild(this.overlay);\n  } else if (this.overlay.parentNode) {\n    this.overlay.parentNode.removeChild(this.overlay);\n  }\n};\n\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */\ndialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n  while (candidate = findNearestDialog(candidate)) {\n    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n      if (dpi.dialog === candidate) {\n        return i === 0;  // only valid if top-most\n      }\n    }\n    candidate = candidate.parentElement;\n  }\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n  if (this.containedByTopDialog_(event.target)) { return; }\n\n  if (document.activeElement === document.documentElement) { return; }\n\n  event.preventDefault();\n  event.stopPropagation();\n  safeBlur(/** @type {Element} */ (event.target));\n\n  if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key\n\n  var dpi = this.pendingDialogStack[0];\n  var dialog = dpi.dialog;\n  var position = dialog.compareDocumentPosition(event.target);\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    if (this.forwardTab_) {\n      // forward\n      dpi.focus_();\n    } else if (event.target !== document.documentElement) {\n      // backwards if we're not already focused on <html>\n      document.documentElement.focus();\n    }\n  }\n\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n  this.forwardTab_ = undefined;\n  if (event.keyCode === 27) {\n    event.preventDefault();\n    event.stopPropagation();\n    var cancelEvent = new supportCustomEvent('cancel', {\n      bubbles: false,\n      cancelable: true\n    });\n    var dpi = this.pendingDialogStack[0];\n    if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {\n      dpi.dialog.close();\n    }\n  } else if (event.keyCode === 9) {\n    this.forwardTab_ = !event.shiftKey;\n  }\n};\n\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */\ndialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n  // This operates on a clone because it may cause it to change. Each change also calls\n  // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n  // at a time?!\n  var clone = this.pendingDialogStack.slice();\n  clone.forEach(function(dpi) {\n    if (removed.indexOf(dpi.dialog) !== -1) {\n      dpi.downgradeModal();\n    } else {\n      dpi.maybeHideModal();\n    }\n  });\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */\ndialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n  var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n  if (this.pendingDialogStack.length >= allowed) {\n    return false;\n  }\n  if (this.pendingDialogStack.unshift(dpi) === 1) {\n    this.blockDocument();\n  }\n  this.updateStacking();\n  return true;\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n */\ndialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n  var index = this.pendingDialogStack.indexOf(dpi);\n  if (index === -1) { return; }\n\n  this.pendingDialogStack.splice(index, 1);\n  if (this.pendingDialogStack.length === 0) {\n    this.unblockDocument();\n  }\n  this.updateStacking();\n};\n\ndialogPolyfill.dm = new dialogPolyfill.DialogManager();\ndialogPolyfill.formSubmitter = null;\ndialogPolyfill.useValue = null;\n\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */\nif (window.HTMLDialogElement === undefined) {\n\n  /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */\n  var testForm = document.createElement('form');\n  testForm.setAttribute('method', 'dialog');\n  if (testForm.method !== 'dialog') {\n    var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');\n    if (methodDescriptor) {\n      // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n      // and don't bother to update the element.\n      var realGet = methodDescriptor.get;\n      methodDescriptor.get = function() {\n        if (isFormMethodDialog(this)) {\n          return 'dialog';\n        }\n        return realGet.call(this);\n      };\n      var realSet = methodDescriptor.set;\n      /** @this {HTMLElement} */\n      methodDescriptor.set = function(v) {\n        if (typeof v === 'string' && v.toLowerCase() === 'dialog') {\n          return this.setAttribute('method', v);\n        }\n        return realSet.call(this, v);\n      };\n      Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);\n    }\n  }\n\n  /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */\n  document.addEventListener('click', function(ev) {\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.useValue = null;\n    if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission\n\n    var target = /** @type {Element} */ (ev.target);\n    if (!target || !isFormMethodDialog(target.form)) { return; }\n\n    var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);\n    if (!valid) {\n      if (!(target.localName === 'input' && target.type === 'image')) { return; }\n      // this is a <input type=\"image\">, which can submit forms\n      dialogPolyfill.useValue = ev.offsetX + ',' + ev.offsetY;\n    }\n\n    var dialog = findNearestDialog(target);\n    if (!dialog) { return; }\n\n    dialogPolyfill.formSubmitter = target;\n\n  }, false);\n\n  /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */\n  var nativeFormSubmit = HTMLFormElement.prototype.submit;\n  var replacementFormSubmit = function () {\n    if (!isFormMethodDialog(this)) {\n      return nativeFormSubmit.call(this);\n    }\n    var dialog = findNearestDialog(this);\n    dialog && dialog.close();\n  };\n  HTMLFormElement.prototype.submit = replacementFormSubmit;\n\n  /**\n   * Global form 'dialog' method handler. Closes a dialog correctly on submit\n   * and possibly sets its return value.\n   */\n  document.addEventListener('submit', function(ev) {\n    if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission\n\n    var form = /** @type {HTMLFormElement} */ (ev.target);\n    if (!isFormMethodDialog(form)) { return; }\n    ev.preventDefault();\n\n    var dialog = findNearestDialog(form);\n    if (!dialog) { return; }\n\n    // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that\n    // the submitter is correct before using its value as .returnValue.\n    var s = dialogPolyfill.formSubmitter;\n    if (s && s.form === form) {\n      dialog.close(dialogPolyfill.useValue || s.value);\n    } else {\n      dialog.close();\n    }\n    dialogPolyfill.formSubmitter = null;\n\n  }, false);\n}\n\nexport default dialogPolyfill;\n","import dialogPolyfill from \"dialog-polyfill\";\n\nconst { openButton, dialog, closeButton, dialogStatus } = window;\n\nfunction setOpenState(open, opener) {\n  if (open) {\n    dialog.showModal();\n  } else {\n    dialog.close();\n  }\n\n  checkStatus(opener);\n}\n\nfunction checkStatus(opener) {\n  dialogStatus.innerText = dialog.open\n    ? `open by ${opener}`\n    : `closed by ${opener}`;\n}\n\nopenButton.addEventListener(\"click\", () => {\n  if (typeof dialog.showModal === \"function\") {\n    setOpenState(true, \"openButton\");\n  } else {\n    dialogPolyfill.registerDialog(dialog);\n  }\n});\n\ncloseButton.addEventListener(\"click\", () => setOpenState(false, \"closeButton\"));\n\ndialog.addEventListener(\"click\", (event) => {\n  // Check if dialog was clicked or the content\n  // dialog = backdrop + content\n  if (event.target === dialog) {\n    setOpenState(false, \"backdrop\");\n  }\n});\n"]}